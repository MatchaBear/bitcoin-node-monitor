#!/bin/bash

# Color definitions
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Function to format numbers with commas
format_number() {
    printf "%'d" $1
}

# Function to calculate percentage change
calc_percent() {
    if [ $2 -ne 0 ]; then
        echo "scale=2; ($1 - $2) * 100 / $2" | bc
    else
        echo "0.00"
    fi
}

# Enhanced display function with all info in one place
show_enhanced_dashboard() {
    clear
    
    # Header
    echo -e "${BOLD}${CYAN}============================================${NC}"
    echo -e "${BOLD}${YELLOW}    🟠 Bitcoin Node & Market Monitor     ${NC}"
    echo -e "${BOLD}${CYAN}============================================${NC}"
    echo -e "${WHITE}📅 $(date '+%Y-%m-%d %H:%M:%S')${NC}"
    echo -e "${CYAN}============================================${NC}"
    echo
    
    # Get all data in one go for efficiency
    sync_info=$(docker exec bitcoin-node bitcoin-cli -rpcuser=bitcoinrpc -rpcpassword=vlN3waFpwnSP90urI8zXxI0L0ZWpzcxN getblockchaininfo 2>/dev/null)
    network_info=$(docker exec bitcoin-node bitcoin-cli -rpcuser=bitcoinrpc -rpcpassword=vlN3waFpwnSP90urI8zXxI0L0ZWpzcxN getnetworkinfo 2>/dev/null)
    mempool_info=$(docker exec bitcoin-node bitcoin-cli -rpcuser=bitcoinrpc -rpcpassword=vlN3waFpwnSP90urI8zXxI0L0ZWpzcxN getmempoolinfo 2>/dev/null)
    
    # Node Status Section
    echo -e "${BOLD}${GREEN}🔧 NODE STATUS${NC}"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    
    if [ $? -eq 0 ] && [ ! -z "$sync_info" ]; then
        headers=$(echo "$sync_info" | grep '"headers"' | grep -o '[0-9]*')
        blocks=$(echo "$sync_info" | grep '"blocks"' | grep -o '[0-9]*')
        connections=$(echo "$network_info" | grep '"connections"' | grep -o '[0-9]*')
        mempool_size=$(echo "$mempool_info" | grep '"size"' | grep -o '[0-9]*')
        mempool_bytes=$(echo "$mempool_info" | grep '"bytes"' | grep -o '[0-9]*')
        
        # Sync status with color
        if [ "$blocks" -eq "$headers" ]; then
            sync_status="${GREEN}✅ Fully Synced${NC}"
        else
            sync_percent=$(echo "scale=2; $blocks * 100 / $headers" | bc)
            sync_status="${YELLOW}⚠️  Syncing ($sync_percent%)${NC}"
        fi
        
        # Peer status with color
        if [ "$connections" -ge 8 ]; then
            peer_status="${GREEN}$connections${NC}"
        elif [ "$connections" -ge 4 ]; then
            peer_status="${YELLOW}$connections${NC}"
        else
            peer_status="${RED}$connections${NC}"
        fi
        
        echo -e "Status: $sync_status"
        echo -e "Height: ${WHITE}$(printf "%'d" $blocks)${NC} / ${WHITE}$(printf "%'d" $headers)${NC}"
        echo -e "Peers: $peer_status"
        echo -e "Mempool: ${WHITE}$(printf "%'d" $mempool_size)${NC} tx ($(echo "scale=1; $mempool_bytes/1024/1024" | bc) MB)"
        
        # Show public IP first (VPN detection for network engineers!) 🕵️‍♂️
        echo -e "${CYAN}🌐 Network Information:${NC}"
        
        # Get public IP with fallback methods
        public_ip=$(curl -s --connect-timeout 5 "https://ipinfo.io/ip" 2>/dev/null || curl -s --connect-timeout 5 "https://api.ipify.org" 2>/dev/null || curl -s --connect-timeout 5 "https://icanhazip.com" 2>/dev/null | tr -d '\n')
        
        if [ ! -z "$public_ip" ] && [[ "$public_ip" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
            # Get ISP/location info
            ip_info=$(curl -s --connect-timeout 5 "https://ipinfo.io/$public_ip" 2>/dev/null)
            if [[ $ip_info == *"org"* ]]; then
                isp=$(echo "$ip_info" | jq -r '.org // "Unknown ISP"' | cut -c1-30)
                city=$(echo "$ip_info" | jq -r '.city // "Unknown"')
                country=$(echo "$ip_info" | jq -r '.country // "Unknown"')
                echo -e "   ${WHITE}Your Public IP:${NC} ${GREEN}$public_ip${NC} ${CYAN}($isp, $city $country)${NC}"
            else
                echo -e "   ${WHITE}Your Public IP:${NC} ${GREEN}$public_ip${NC} ${CYAN}(ISP lookup failed)${NC}"
            fi
            
            # VPN Detection hint
            if [[ "$isp" == *"VPN"* ]] || [[ "$isp" == *"Proxy"* ]] || [[ "$isp" == *"Virtual"* ]] || [[ "$isp" == *"Private"* ]]; then
                echo -e "   ${YELLOW}🔒 VPN/Proxy detected!${NC}"
            fi
        else
            echo -e "   ${RED}❌ Could not determine public IP${NC}"
        fi
        
        # Show peer IP addresses
        echo -e "   ${CYAN}Connected Peers:${NC}"
        peer_ips=$(docker exec bitcoin-node bitcoin-cli -rpcuser=bitcoinrpc -rpcpassword=vlN3waFpwnSP90urI8zXxI0L0ZWpzcxN getpeerinfo 2>/dev/null | jq -r '.[].addr' | head -5)
        if [ ! -z "$peer_ips" ]; then
            echo "$peer_ips" | while read ip; do
                if [ ! -z "$ip" ]; then
                    # Extract just IP without port for geolocation hint
                    clean_ip=$(echo "$ip" | cut -d':' -f1 | sed 's/\[//g' | sed 's/\]//g')
                    echo -e "     ${WHITE}$ip${NC} ${CYAN}($clean_ip)${NC}"
                fi
            done
        else
            echo -e "     ${YELLOW}No peer data available${NC}"
        fi
    else
        echo -e "${RED}❌ Node connection failed${NC}"
    fi
    echo
    
    # Price Section (call existing function but enhanced)
    echo -e "${BOLD}${PURPLE}💰 MARKET DATA ${CYAN}(Live CoinGecko API)${NC}"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    
    # Get current price data and market data separately for better reliability
    api_time=$(date '+%H:%M:%S')
    sg_time=$(TZ='Asia/Singapore' date '+%H:%M:%S')
    jkt_time=$(TZ='Asia/Jakarta' date '+%H:%M:%S')
    echo -e "${CYAN}📡 Last fetched: $api_time UTC | $sg_time SGT | $jkt_time WIB${NC}"
    
    # Try CoinGecko market data API for more complete information
    price_data=$(curl -s --connect-timeout 10 "https://api.coingecko.com/api/v3/coins/bitcoin/market_chart?vs_currency=usd&days=1" 2>/dev/null)
    basic_price=$(curl -s --connect-timeout 10 "https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd,eur,gbp,sgd,chf,jpy,krw,idr" 2>/dev/null)
    # Calculate 24h change from market chart data and get current prices
    if [[ $basic_price == *"usd"* ]]; then
        # Get current prices
        usd_price=$(echo "$basic_price" | jq -r '.bitcoin.usd // 0')
        eur_price=$(echo "$basic_price" | jq -r '.bitcoin.eur // 0')
        gbp_price=$(echo "$basic_price" | jq -r '.bitcoin.gbp // 0')
        sgd_price=$(echo "$basic_price" | jq -r '.bitcoin.sgd // 0')
        chf_price=$(echo "$basic_price" | jq -r '.bitcoin.chf // 0')
        jpy_price=$(echo "$basic_price" | jq -r '.bitcoin.jpy // 0')
        krw_price=$(echo "$basic_price" | jq -r '.bitcoin.krw // 0')
        idr_price=$(echo "$basic_price" | jq -r '.bitcoin.idr // 0')
        
        # Calculate 24h change from price chart data
        if [[ $price_data == *"prices"* ]]; then
            price_24h_ago=$(echo "$price_data" | jq -r '.prices[0][1] // 0')
            current_usd=$(echo "$price_data" | jq -r '.prices[-1][1] // 0')
            if [[ "$current_usd" != "0" && "$price_24h_ago" != "0" ]]; then
                usd_change_pct=$(echo "scale=4; (($current_usd - $price_24h_ago) / $price_24h_ago) * 100" | bc 2>/dev/null || echo "0")
                usd_change_raw=$(echo "scale=2; $current_usd - $price_24h_ago" | bc 2>/dev/null || echo "0")
            else
                usd_change_pct="0"
                usd_change_raw="0"
            fi
        else
            usd_change_pct="0"
            usd_change_raw="0"
        fi
        
        # Calculate raw changes for other currencies based on percentage
        eur_change_pct="$usd_change_pct"
        gbp_change_pct="$usd_change_pct"
        sgd_change_pct="$usd_change_pct"
        chf_change_pct="$usd_change_pct"
        jpy_change_pct="$usd_change_pct"
        krw_change_pct="$usd_change_pct"
        idr_change_pct="$usd_change_pct"
        
        # Calculate raw currency changes
        eur_change_raw=$(echo "scale=2; $eur_price * $eur_change_pct / 100" | bc 2>/dev/null || echo "0")
        gbp_change_raw=$(echo "scale=2; $gbp_price * $gbp_change_pct / 100" | bc 2>/dev/null || echo "0")
        sgd_change_raw=$(echo "scale=2; $sgd_price * $sgd_change_pct / 100" | bc 2>/dev/null || echo "0")
        chf_change_raw=$(echo "scale=2; $chf_price * $chf_change_pct / 100" | bc 2>/dev/null || echo "0")
        jpy_change_raw=$(echo "scale=0; $jpy_price * $jpy_change_pct / 100" | bc 2>/dev/null || echo "0")
        krw_change_raw=$(echo "scale=0; $krw_price * $krw_change_pct / 100" | bc 2>/dev/null || echo "0")
        idr_change_raw=$(echo "scale=0; $idr_price * $idr_change_pct / 100" | bc 2>/dev/null || echo "0")
        
        # Function to format change for any currency with both percentage and raw values
        format_change() {
            local change_pct="$1"
            local change_raw="$2"
            local currency_symbol="$3"
            local change_abs
            local change_color
            local change_symbol
            
            # Handle null or empty values
            if [[ "$change_pct" == "null" || "$change_pct" == "" ]]; then
                change_pct="0"
            fi
            if [[ "$change_raw" == "null" || "$change_raw" == "" ]]; then
                change_raw="0"
            fi
            
            # Calculate absolute value
            change_abs=$(echo "$change_pct" | sed 's/-//' | bc 2>/dev/null || echo "0")
            
            # Determine color and symbol
            if (( $(echo "$change_pct > 0" | bc -l 2>/dev/null || echo 0) )); then
                change_color=$GREEN
                change_symbol="▲"
            elif (( $(echo "$change_pct < 0" | bc -l 2>/dev/null || echo 0) )); then
                change_color=$RED
                change_symbol="▼"
            else
                change_color=$YELLOW
                change_symbol="═"
            fi
            
            # Format the percentage change
            if (( $(echo "$change_abs > 0.01" | bc 2>/dev/null || echo 0) )); then
                pct_formatted=$(printf "%.2f" "$change_pct" 2>/dev/null || echo "0.00")
            else
                pct_formatted=$(printf "%.3f" "$change_pct" 2>/dev/null || echo "0.000")
            fi
            
            # Format raw change based on currency
            if [[ "$currency_symbol" == "¥" || "$currency_symbol" == "₩" || "$currency_symbol" == "Rp." ]]; then
                raw_formatted=$(printf "%.0f" "$change_raw" 2>/dev/null || echo "0")
            else
                raw_formatted=$(printf "%.2f" "$change_raw" 2>/dev/null || echo "0.00")
            fi
            
            # Create plus/minus sign for raw value
            if (( $(echo "$change_raw > 0" | bc -l 2>/dev/null || echo 0) )); then
                raw_sign="+"
            elif (( $(echo "$change_raw < 0" | bc -l 2>/dev/null || echo 0) )); then
                raw_sign=""
            else
                raw_sign=""
            fi
            
            echo "${change_color}$change_symbol $pct_formatted% ($raw_sign$currency_symbol$raw_formatted)${NC}"
        }
        
        # Display all currencies with consistent formatting (15 chars width)
        echo -e "USD: ${WHITE}\$$(printf "%'14.2f" "$usd_price")${NC} $(format_change "$usd_change_pct" "$usd_change_raw" "\$")"
        echo -e "EUR: ${WHITE}€$(printf "%'15.2f" "$eur_price")${NC} $(format_change "$eur_change_pct" "$eur_change_raw" "€")"
        echo -e "GBP: ${WHITE}£$(printf "%'15.2f" "$gbp_price")${NC} $(format_change "$gbp_change_pct" "$gbp_change_raw" "£")"
        echo -e "SGD: ${WHITE}S\$$(printf "%'14.2f" "$sgd_price")${NC} $(format_change "$sgd_change_pct" "$sgd_change_raw" "S\$")"
        echo -e "CHF: ${WHITE}CHF$(printf "%'13.2f" "$chf_price")${NC} $(format_change "$chf_change_pct" "$chf_change_raw" "CHF")"
        echo -e "JPY: ${WHITE}¥$(printf "%'15.0f" "$jpy_price")${NC} $(format_change "$jpy_change_pct" "$jpy_change_raw" "¥")"
        echo -e "KRW: ${WHITE}₩$(printf "%'15.0f" "$krw_price")${NC} $(format_change "$krw_change_pct" "$krw_change_raw" "₩")"
        echo -e "IDR: ${WHITE}Rp.$(printf "%'13.0f" "$idr_price")${NC} $(format_change "$idr_change_pct" "$idr_change_raw" "Rp.")"
    else
        echo -e "${RED}❌ Price data unavailable${NC}"
    fi
    echo
    
    # ATH Section (separate)
    echo -e "${BOLD}${PURPLE}📊 ALL-TIME HIGH (ATH)${NC}"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    
    # Get ATH data
    ath_data=$(curl -s "https://api.coingecko.com/api/v3/coins/bitcoin?localization=false&tickers=false&market_data=true&community_data=false&developer_data=false&sparkline=false")
    if [[ $ath_data == *"ath"* ]]; then
        usd_ath=$(echo "$ath_data" | jq -r '.market_data.ath.usd // 73817')
        eur_ath=$(echo "$ath_data" | jq -r '.market_data.ath.eur // 68000')
        gbp_ath=$(echo "$ath_data" | jq -r '.market_data.ath.gbp // 58000')
        sgd_ath=$(echo "$ath_data" | jq -r '.market_data.ath.sgd // 98564')
        chf_ath=$(echo "$ath_data" | jq -r '.market_data.ath.chf // 68000')
        jpy_ath=$(echo "$ath_data" | jq -r '.market_data.ath.jpy // 11500000')
        krw_ath=$(echo "$ath_data" | jq -r '.market_data.ath.krw // 150000000')
        idr_ath=$(echo "$ath_data" | jq -r '.market_data.ath.idr // 1143000000')
        
        echo -e "USD: ${YELLOW}\$$(printf "%'12.2f" "$usd_ath")${NC}"
        echo -e "EUR: ${YELLOW}€$(printf "%'12.2f" "$eur_ath")${NC}"
        echo -e "GBP: ${YELLOW}£$(printf "%'12.2f" "$gbp_ath")${NC}"
        echo -e "SGD: ${YELLOW}S\$$(printf "%'11.2f" "$sgd_ath")${NC}"
        echo -e "CHF: ${YELLOW}CHF$(printf "%'9.2f" "$chf_ath")${NC}"
        echo -e "JPY: ${YELLOW}¥$(printf "%'11.0f" "$jpy_ath")${NC}"
        echo -e "KRW: ${YELLOW}₩$(printf "%'11.0f" "$krw_ath")${NC}"
        echo -e "IDR: ${YELLOW}Rp.$(printf "%'9.0f" "$idr_ath")${NC}"
    else
        echo -e "${RED}❌ ATH data unavailable${NC}"
    fi
    echo
    
    # Supply Section (optimized, no external script call)
    echo -e "${BOLD}${BLUE}⚡ SUPPLY INFO${NC}"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    
    if [ ! -z "$blocks" ]; then
        # Calculate supply efficiently
        current_height=$blocks
        max_supply=21000000
        halving_interval=210000
        current_era=$((current_height / halving_interval))
        current_reward=$(echo "scale=8; 50 / (2 ^ $current_era)" | bc)
        
        # Simple supply calculation
        total_supply=0
        temp_height=$current_height
        reward=50
        
        for ((i=0; i<$current_era; i++)); do
            total_supply=$(echo "$total_supply + ($halving_interval * $reward)" | bc)
            reward=$(echo "scale=8; $reward / 2" | bc)
            temp_height=$((temp_height - halving_interval))
        done
        
        total_supply=$(echo "$total_supply + ($temp_height * $reward)" | bc)
        remaining=$(echo "$max_supply - $total_supply" | bc)
        percent_mined=$(echo "scale=6; $total_supply * 100 / $max_supply" | bc)
        
        # Next halving
        next_halving=$(( ((current_height/halving_interval)+1)*halving_interval ))
        blocks_to_halving=$((next_halving - current_height))
        days_to_halving=$((blocks_to_halving * 10 / 1440))
        
        echo -e "Current Supply: ${WHITE}$(printf "%'.0f" "$total_supply")${NC} BTC (${percent_mined}%)"
        echo -e "Remaining: ${WHITE}$(printf "%'.0f" "$remaining")${NC} BTC"
        echo -e "Block Reward: ${WHITE}$current_reward${NC} BTC"
        echo -e "Next Halving: ${YELLOW}$(printf "%'d" $blocks_to_halving)${NC} blocks (~$days_to_halving days)"
    else
        echo -e "${RED}❌ Supply data unavailable${NC}"
    fi
    echo
    
    # Footer
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${WHITE}🔄 Auto-refresh in 30s | Press ${BOLD}Ctrl+C${NC}${WHITE} to exit${NC}"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
}

clear
echo -e "${BOLD}${GREEN}Starting Bitcoin Node Monitor...${NC}"
sleep 1

while true; do
    show_enhanced_dashboard
    sleep 30
done
